"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.downloadAndValidateBinary = void 0;
const chalk_1 = __importDefault(require("chalk"));
const crypto_1 = __importDefault(require("crypto"));
const fs_1 = __importDefault(require("fs"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const ora_1 = __importDefault(require("ora"));
const path_1 = __importDefault(require("path"));
const stream_1 = require("stream");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
/**
 * Downloads the binary to the given output folder
 * @param releaseMetadata binary metadata
 * @param binaryType StaticSiteClient or DataApiBuilder
 * @param outputFolder path to download the binary
 * @param id buildId or versionId
 * @param platform os: win-x64 or linux-x64 or osx-x64
 * @returns
 */
async function downloadAndValidateBinary(releaseMetadata, binaryName, outputFolder, id, platform) {
    var _a;
    const downloadFilename = path_1.default.basename(releaseMetadata.files[platform].url);
    const url = releaseMetadata.files[platform].url;
    const spinner = (0, ora_1.default)({ prefixText: chalk_1.default.dim.gray(`[swa]`) });
    spinner.start(`Downloading ${url}@${id}`);
    const response = await (0, node_fetch_1.default)(url);
    if (response.status !== 200) {
        spinner.fail();
        throw new Error(`Failed to download ${binaryName} binary from url ${url}. File not found (${response.status})`);
    }
    const bodyStream = (_a = response === null || response === void 0 ? void 0 : response.body) === null || _a === void 0 ? void 0 : _a.pipe(new stream_1.PassThrough());
    createBinaryDirectoryIfNotExists(id, outputFolder);
    return await new Promise((resolve, reject) => {
        const isPosix = platform === "linux-x64" || platform === "osx-x64";
        const outputFile = path_1.default.join(outputFolder, id, downloadFilename);
        const writableStream = fs_1.default.createWriteStream(outputFile, { mode: isPosix ? 0o755 : undefined });
        bodyStream === null || bodyStream === void 0 ? void 0 : bodyStream.pipe(writableStream);
        writableStream.on("end", () => {
            bodyStream === null || bodyStream === void 0 ? void 0 : bodyStream.end();
        });
        writableStream.on("finish", async () => {
            const computedHash = computeChecksumfromFile(outputFile).toLowerCase();
            const releaseChecksum = releaseMetadata.files[platform].sha.toLowerCase();
            if (computedHash !== releaseChecksum) {
                try {
                    // in case of a failure, we remove the file
                    fs_1.default.unlinkSync(outputFile);
                }
                catch {
                    utils_1.logger.silly(`Not able to delete ${downloadFilename}, please delete manually.`);
                }
                spinner.fail();
                reject(new Error(`Checksum mismatch for ${binaryName}! Expected ${releaseChecksum}, got ${computedHash}.`));
            }
            else {
                spinner.succeed();
                utils_1.logger.silly(`Checksum match: ${computedHash}`);
                utils_1.logger.silly(`Saved binary to ${outputFile}`);
                saveMetadata(releaseMetadata, outputFile, computedHash, binaryName);
                resolve(outputFile);
            }
        });
        // writableStream.close();
    });
}
exports.downloadAndValidateBinary = downloadAndValidateBinary;
/**
 * Creates the output folder for downloading the binary
 * @param version version
 * @param outputFolder path to download the binary
 */
function createBinaryDirectoryIfNotExists(version, outputFolder) {
    const deployPath = path_1.default.join(outputFolder, version);
    if (!fs_1.default.existsSync(deployPath)) {
        fs_1.default.mkdirSync(deployPath, { recursive: true });
    }
}
/**
 * Computes and returns the sha256 hash value for the given file
 * @param filePath filePath
 * @returns sha256 checksum of the file
 */
function computeChecksumfromFile(filePath) {
    if (!filePath || !fs_1.default.existsSync(filePath)) {
        return "";
    }
    const buffer = fs_1.default.readFileSync(filePath);
    const hash = crypto_1.default.createHash("sha256");
    hash.update(buffer);
    return hash.digest("hex");
}
/**
 *
 * @param release binary Metadata
 * @param binaryFileName binary file location
 * @param sha hash value
 * @param binaryType StaticSiteClient or DataApiBuilder
 */
function saveMetadata(release, binaryFileName, sha, binaryName) {
    const downloadFolder = getFolderForSavingMetadata(binaryName);
    if (downloadFolder != null) {
        const metadataFileName = path_1.default.join(downloadFolder, `${binaryName}.json`);
        const metdata = {
            metadata: release,
            binary: binaryFileName,
            checksum: sha,
        };
        fs_1.default.writeFileSync(metadataFileName, JSON.stringify(metdata));
        utils_1.logger.silly(`Saved metadata to ${metadataFileName}`);
    }
}
/**
 * Returns folder for saving binary metadata
 * @param binaryName
 * @returns folder
 */
function getFolderForSavingMetadata(binaryName) {
    switch (binaryName) {
        case constants_1.DEPLOY_BINARY_NAME:
            return constants_1.DEPLOY_FOLDER;
        case constants_1.DATA_API_BUILDER_BINARY_NAME:
            return constants_1.DATA_API_BUILDER_FOLDER;
        default:
            return null;
    }
}
//# sourceMappingURL=download-binary-helper.js.map