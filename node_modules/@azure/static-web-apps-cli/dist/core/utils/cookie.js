"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CookiesManager = exports.decodeAuthContextCookie = exports.validateAuthContextCookie = exports.decodeCookie = exports.validateCookie = exports.serializeCookie = void 0;
const chalk_1 = __importDefault(require("chalk"));
const cookie_1 = __importDefault(require("cookie"));
const constants_1 = require("../constants");
const auth_1 = require("./auth");
const logger_1 = require("./logger");
/**
 * Serialize a cookie name-value pair into a string that can be used in Set-Cookie header.
 * @param cookieName The name for the cookie.
 * @param cookieValue The value to set the cookie to.
 * @param options An object containing serialization options
 * @throws {TypeError} when maxAge options is invalid.
 * @returns The serialized value.
 */
function serializeCookie(cookieName, cookieValue, options) {
    return cookie_1.default.serialize(cookieName, cookieValue, options);
}
exports.serializeCookie = serializeCookie;
/**
 * Check if the StaticWebAppsAuthCookie is available.
 * @param cookieValue The cookie value.
 * @returns True if StaticWebAppsAuthCookie is found. False otherwise.
 */
function validateCookie(cookieValue) {
    return validateCookieByName(constants_1.SWA_AUTH_COOKIE, cookieValue);
}
exports.validateCookie = validateCookie;
/**
 *
 * @param cookieValue
 * @returns A ClientPrincipal object.
 */
function decodeCookie(cookieValue) {
    const stringValue = decodeCookieByName(constants_1.SWA_AUTH_COOKIE, cookieValue);
    return stringValue ? JSON.parse(stringValue) : null;
}
exports.decodeCookie = decodeCookie;
/**
 * Check if the StaticWebAppsAuthContextCookie is available.
 * @param cookieValue The cookie value.
 * @returns True if StaticWebAppsAuthContextCookie is found. False otherwise.
 */
function validateAuthContextCookie(cookieValue) {
    return validateCookieByName(constants_1.SWA_AUTH_CONTEXT_COOKIE, cookieValue);
}
exports.validateAuthContextCookie = validateAuthContextCookie;
/**
 *
 * @param cookieValue
 * @returns StaticWebAppsAuthContextCookie string.
 */
function decodeAuthContextCookie(cookieValue) {
    const stringValue = decodeCookieByName(constants_1.SWA_AUTH_CONTEXT_COOKIE, cookieValue);
    return stringValue ? JSON.parse(stringValue) : null;
}
exports.decodeAuthContextCookie = decodeAuthContextCookie;
// local functions
function getCookie(cookieName, cookies) {
    const nonChunkedCookie = cookies[cookieName];
    if (nonChunkedCookie) {
        // prefer the non-chunked cookie if it exists
        return nonChunkedCookie;
    }
    let chunkedCookie = "";
    let chunk = "";
    let index = 0;
    do {
        chunkedCookie = `${chunkedCookie}${chunk}`;
        chunk = cookies[`${cookieName}_${index}`];
        index += 1;
    } while (chunk);
    return chunkedCookie;
}
function validateCookieByName(cookieName, cookieValue) {
    if (typeof cookieValue !== "string") {
        throw Error(`TypeError: cookie value must be a string`);
    }
    const cookies = cookie_1.default.parse(cookieValue);
    return !!getCookie(cookieName, cookies);
}
function decodeCookieByName(cookieName, cookieValue) {
    logger_1.logger.silly(`decoding ${cookieName} cookie`);
    const cookies = cookie_1.default.parse(cookieValue);
    const value = getCookie(cookieName, cookies);
    if (value) {
        const decodedValue = Buffer.from(value, "base64").toString();
        logger_1.logger.silly(` - ${cookieName} decoded: ${chalk_1.default.yellow(decodedValue)}`);
        if (!decodedValue) {
            logger_1.logger.silly(` - failed to decode '${cookieName}'`);
            return null;
        }
        if ((0, auth_1.isValueEncryptedAndSigned)(decodedValue)) {
            const decryptedValue = (0, auth_1.validateSignatureAndDecrypt)(decodedValue);
            logger_1.logger.silly(` - ${cookieName} decrypted: ${chalk_1.default.yellow(decryptedValue)}`);
            if (!decryptedValue) {
                logger_1.logger.silly(` - failed to validate and decrypt '${cookieName}'`);
                return null;
            }
            return decryptedValue;
        }
        return decodedValue;
    }
    logger_1.logger.silly(` - no cookie '${cookieName}' found`);
    return null;
}
class CookiesManager {
    constructor(requestCookie) {
        this._chunkSize = 2000;
        this._cookiesToSet = {};
        this._cookiesToDelete = {};
        this._existingCookies = requestCookie ? cookie_1.default.parse(requestCookie) : {};
    }
    _generateDeleteChunks(name, force /* add the delete cookie even if the corresponding cookie doesn't exist */) {
        const cookies = {};
        // check for unchunked cookie
        if (force || this._existingCookies[name]) {
            cookies[name] = {
                name: name,
                value: "deleted",
                path: "/",
                httpOnly: false,
                expires: new Date(1).toUTCString(),
            };
        }
        // check for chunked cookie
        let found = true;
        let index = 0;
        while (found) {
            const chunkName = `${name}_${index}`;
            found = !!this._existingCookies[chunkName];
            if (found) {
                cookies[chunkName] = {
                    name: chunkName,
                    value: "deleted",
                    path: "/",
                    httpOnly: false,
                    expires: new Date(1).toUTCString(),
                };
            }
            index += 1;
        }
        return cookies;
    }
    _generateChunks(options) {
        const { name, value } = options;
        // pre-populate with cookies for deleting existing chunks
        const cookies = this._generateDeleteChunks(options.name, false);
        // generate chunks
        if (value !== "deleted") {
            const chunkCount = Math.ceil(value.length / this._chunkSize);
            let index = 0;
            let chunkName = "";
            while (index < chunkCount) {
                const position = index * this._chunkSize;
                const chunk = value.substring(position, position + this._chunkSize);
                chunkName = `${name}_${index}`;
                cookies[chunkName] = {
                    ...options,
                    name: chunkName,
                    value: chunk,
                };
                index += 1;
            }
        }
        return Object.values(cookies);
    }
    addCookieToSet(options) {
        this._cookiesToSet[options.name.toLowerCase()] = options;
    }
    addCookieToDelete(name) {
        this._cookiesToDelete[name.toLowerCase()] = name;
    }
    getCookies() {
        const allCookies = [];
        Object.values(this._cookiesToDelete).forEach((cookieName) => {
            const chunks = this._generateDeleteChunks(cookieName, true);
            allCookies.push(...Object.values(chunks));
        });
        Object.values(this._cookiesToSet).forEach((cookie) => {
            const chunks = this._generateChunks(cookie);
            allCookies.push(...chunks);
        });
        return allCookies;
    }
}
exports.CookiesManager = CookiesManager;
//# sourceMappingURL=cookie.js.map