"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cleanUp = exports.fetchClientVersionDefinition = exports.getLocalClientMetadata = exports.getDeployClientPath = void 0;
const fs_1 = __importDefault(require("fs"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const constants_1 = require("./constants");
const download_binary_helper_1 = require("./download-binary-helper");
const env_1 = require("./env");
const utils_1 = require("./utils");
async function getDeployClientPath() {
    const platform = (0, utils_1.getPlatform)();
    if (!platform) {
        throw new Error(`Unsupported platform: ${os_1.default.platform()}`);
    }
    const localClientMetadata = getLocalClientMetadata();
    const binaryVersion = (0, env_1.swaCLIEnv)().SWA_CLI_DEPLOY_BINARY_VERSION || constants_1.DEPLOY_BINARY_STABLE_TAG;
    const remoteClientMetadata = await fetchClientVersionDefinition(binaryVersion);
    if (remoteClientMetadata === undefined) {
        throw new Error(`Could not load ${constants_1.DEPLOY_BINARY_NAME} metadata from remote. Please check your internet connection.`);
    }
    // if the latest version is the same as the local version, we can skip the download
    if (localClientMetadata) {
        if (!localClientMetadata.metadata || !localClientMetadata.binary || !localClientMetadata.checksum) {
            utils_1.logger.warn(`Local client metadata is invalid!`);
        }
        else {
            const localChecksum = localClientMetadata.checksum;
            const releaseChecksum = remoteClientMetadata.files[platform].sha.toLowerCase();
            const remoteBuildId = remoteClientMetadata.buildId;
            const localBuildId = localClientMetadata.metadata.buildId;
            if (remoteBuildId === localBuildId) {
                if (localChecksum === releaseChecksum) {
                    utils_1.logger.silly(`Local client binary is up to date. Skipping download.`);
                    return {
                        binary: localClientMetadata.binary,
                        buildId: localBuildId,
                    };
                }
                else {
                    utils_1.logger.warn(`Local metatada contains invalid checksum hash!`);
                    utils_1.logger.warn(`  Expected ${releaseChecksum}`);
                    utils_1.logger.warn(`  Received ${localChecksum}`);
                }
            }
            else {
                if (localBuildId) {
                    utils_1.logger.warn(`${constants_1.DEPLOY_BINARY_NAME} is outdated! Expected ${remoteBuildId}, got ${localBuildId}`);
                }
            }
        }
    }
    return {
        binary: await (0, download_binary_helper_1.downloadAndValidateBinary)(remoteClientMetadata, constants_1.DEPLOY_BINARY_NAME, constants_1.DEPLOY_FOLDER, remoteClientMetadata.buildId, platform),
        buildId: remoteClientMetadata.buildId,
    };
}
exports.getDeployClientPath = getDeployClientPath;
function getLocalClientMetadata() {
    const metadataFilename = path_1.default.join(constants_1.DEPLOY_FOLDER, `${constants_1.DEPLOY_BINARY_NAME}.json`);
    if (!fs_1.default.existsSync(metadataFilename)) {
        utils_1.logger.warn(`Could not find ${constants_1.DEPLOY_BINARY_NAME} local binary`);
        return null;
    }
    let metadata = null;
    try {
        metadata = JSON.parse(fs_1.default.readFileSync(metadataFilename, "utf8"));
    }
    catch (err) {
        utils_1.logger.warn(`Could not read ${constants_1.DEPLOY_BINARY_NAME} metadata: ${err}`);
        return null;
    }
    if (metadata) {
        if (!fs_1.default.existsSync(metadata.binary)) {
            utils_1.logger.warn(`Could not find ${constants_1.DEPLOY_BINARY_NAME} binary: ${metadata.binary}`);
            return null;
        }
        else if (fs_1.default.existsSync(metadata.binary)) {
            return metadata;
        }
    }
    return null;
}
exports.getLocalClientMetadata = getLocalClientMetadata;
async function fetchClientVersionDefinition(releaseVersion) {
    utils_1.logger.silly(`Fetching release metadata for version: ${releaseVersion}. Please wait...`);
    const remoteVersionDefinitions = (await (0, node_fetch_1.default)(constants_1.STATIC_SITE_CLIENT_RELEASE_METADATA_URL).then((res) => res.json()));
    if (Array.isArray(remoteVersionDefinitions) && remoteVersionDefinitions.length) {
        const releaseMetadata = remoteVersionDefinitions.find((versionDefinition) => (versionDefinition === null || versionDefinition === void 0 ? void 0 : versionDefinition.version) === releaseVersion);
        utils_1.logger.silly(releaseMetadata);
        return releaseMetadata;
    }
    return undefined;
}
exports.fetchClientVersionDefinition = fetchClientVersionDefinition;
// TODO: get StaticSiteClient to remove zip files
// TODO: can these ZIPs be created under /tmp?
function cleanUp() {
    const clean = (file) => {
        const filepath = path_1.default.join(process.cwd(), file);
        if (fs_1.default.existsSync(filepath)) {
            try {
                fs_1.default.unlinkSync(filepath);
            }
            catch { }
        }
    };
    clean(".\\app.zip");
    clean(".\\api.zip");
}
exports.cleanUp = cleanUp;
//# sourceMappingURL=deploy-client.js.map