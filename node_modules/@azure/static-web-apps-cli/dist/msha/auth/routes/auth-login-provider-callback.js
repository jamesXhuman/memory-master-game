"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("../../../core");
const http = __importStar(require("http"));
const https = __importStar(require("https"));
const querystring = __importStar(require("querystring"));
const constants_1 = require("../../../core/constants");
const config_1 = require("../../../config");
const auth_1 = require("../../../core/utils/auth");
const getGithubAuthToken = function (codeValue, clientId, clientSecret) {
    const data = querystring.stringify({
        code: codeValue,
        client_id: clientId,
        client_secret: clientSecret,
    });
    const options = {
        host: "github.com",
        path: "/login/oauth/access_token",
        method: "POST",
        headers: {
            "Content-Type": "application/x-www-form-urlencoded",
            "Content-Length": Buffer.byteLength(data),
        },
    };
    return new Promise((resolve, reject) => {
        const req = https.request(options, (res) => {
            res.setEncoding("utf8");
            let responseBody = "";
            res.on("data", (chunk) => {
                responseBody += chunk;
            });
            res.on("end", () => {
                resolve(responseBody);
            });
        });
        req.on("error", (err) => {
            reject(err);
        });
        req.write(data);
        req.end();
    });
};
const getGitHubUser = function (accessToken) {
    const options = {
        host: "api.github.com",
        path: "/user",
        method: "GET",
        headers: {
            Authorization: `Bearer ${accessToken}`,
            "User-Agent": "Azure Static Web Apps Emulator",
        },
    };
    return new Promise((resolve, reject) => {
        const req = https.request(options, (res) => {
            res.setEncoding("utf8");
            let responseBody = "";
            res.on("data", (chunk) => {
                responseBody += chunk;
            });
            res.on("end", () => {
                try {
                    resolve(JSON.parse(responseBody));
                }
                catch (err) {
                    reject(err);
                }
            });
        });
        req.on("error", (err) => {
            reject(err);
        });
        req.end();
    });
};
const getGitHubClientPrincipal = async function (codeValue, clientId, clientSecret) {
    let authToken;
    try {
        const authTokenResponse = (await getGithubAuthToken(codeValue, clientId, clientSecret));
        const authTokenParsed = querystring.parse(authTokenResponse);
        authToken = authTokenParsed["access_token"];
    }
    catch {
        return null;
    }
    if (!authToken) {
        return null;
    }
    try {
        const user = (await getGitHubUser(authToken));
        const userId = user["id"];
        const userDetails = user["login"];
        const claims = [
            {
                typ: "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier",
                val: userId,
            },
        ];
        Object.keys(user).forEach((key) => {
            claims.push({
                typ: `urn:github:${key}`,
                val: user[key],
            });
        });
        return {
            identityProvider: "github",
            userId,
            userDetails,
            userRoles: ["authenticated", "anonymous"],
            claims,
        };
    }
    catch {
        return null;
    }
};
const getGoogleAuthToken = function (codeValue, clientId, clientSecret) {
    const data = querystring.stringify({
        code: codeValue,
        client_id: clientId,
        client_secret: clientSecret,
        grant_type: "authorization_code",
        redirect_uri: `${constants_1.SWA_CLI_APP_PROTOCOL}://${config_1.DEFAULT_CONFIG.host}:${config_1.DEFAULT_CONFIG.port}/.auth/login/google/callback`,
    });
    const options = {
        host: "oauth2.googleapis.com",
        path: "/token",
        method: "POST",
        headers: {
            "Content-Type": "application/x-www-form-urlencoded",
            "Content-Length": Buffer.byteLength(data),
        },
    };
    return new Promise((resolve, reject) => {
        const req = https.request(options, (res) => {
            res.setEncoding("utf8");
            let responseBody = "";
            res.on("data", (chunk) => {
                responseBody += chunk;
            });
            res.on("end", () => {
                resolve(responseBody);
            });
        });
        req.on("error", (err) => {
            reject(err);
        });
        req.write(data);
        req.end();
    });
};
const getGoogleUser = function (accessToken) {
    const options = {
        host: "www.googleapis.com",
        path: "/oauth2/v2/userinfo",
        method: "GET",
        headers: {
            Authorization: `Bearer ${accessToken}`,
            "User-Agent": "Azure Static Web Apps Emulator",
        },
    };
    return new Promise((resolve, reject) => {
        const req = https.request(options, (res) => {
            res.setEncoding("utf8");
            let responseBody = "";
            res.on("data", (chunk) => {
                responseBody += chunk;
            });
            res.on("end", () => {
                try {
                    resolve(JSON.parse(responseBody));
                }
                catch (err) {
                    reject(err);
                }
            });
        });
        req.on("error", (err) => {
            reject(err);
        });
        req.end();
    });
};
const getGoogleClientPrincipal = async function (codeValue, clientId, clientSecret) {
    let authToken;
    try {
        const authTokenResponse = (await getGoogleAuthToken(codeValue, clientId, clientSecret));
        const authTokenParsed = JSON.parse(authTokenResponse);
        authToken = authTokenParsed["access_token"];
    }
    catch {
        return null;
    }
    if (!authToken) {
        return null;
    }
    try {
        const user = (await getGoogleUser(authToken));
        const userId = user["id"];
        const userDetails = user["email"];
        const verifiedEmail = user["verified_email"];
        const name = user["name"];
        const givenName = user["given_name"];
        const familyName = user["family_name"];
        const picture = user["picture"];
        const claims = [
            {
                typ: "iss",
                val: "https://accounts.google.com",
            },
            {
                typ: "azp",
                val: clientId,
            },
            {
                typ: "aud",
                val: clientId,
            },
        ];
        if (userId) {
            claims.push({
                typ: "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier",
                val: userId,
            });
        }
        if (userDetails) {
            claims.push({
                typ: "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress",
                val: userDetails,
            });
        }
        if (verifiedEmail !== undefined) {
            claims.push({
                typ: "email_verified",
                val: verifiedEmail,
            });
        }
        if (name) {
            claims.push({
                typ: "name",
                val: name,
            });
        }
        if (picture) {
            claims.push({
                typ: "picture",
                val: picture,
            });
        }
        if (givenName) {
            claims.push({
                typ: "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname",
                val: givenName,
            });
        }
        if (familyName) {
            claims.push({
                typ: "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname",
                val: familyName,
            });
        }
        return {
            identityProvider: "google",
            userId,
            userDetails,
            claims,
            userRoles: ["authenticated", "anonymous"],
        };
    }
    catch {
        return null;
    }
};
const getRoles = function (clientPrincipal, rolesSource) {
    let cliApiUri = (0, constants_1.SWA_CLI_API_URI)();
    const { protocol, hostname, port } = (0, core_1.parseUrl)(cliApiUri);
    const target = hostname === "localhost" ? `${protocol}//127.0.0.1:${port}` : cliApiUri;
    const targetUrl = new URL(target);
    const data = JSON.stringify(clientPrincipal);
    const options = {
        host: targetUrl.hostname,
        port: targetUrl.port,
        path: rolesSource,
        method: "POST",
        headers: {
            "Content-Type": "application/json",
            "Content-Length": Buffer.byteLength(data),
        },
    };
    return new Promise((resolve, reject) => {
        const protocolModule = targetUrl.protocol === "https:" ? https : http;
        const req = protocolModule.request(options, (res) => {
            res.setEncoding("utf8");
            let responseBody = "";
            res.on("data", (chunk) => {
                responseBody += chunk;
            });
            res.on("end", () => {
                try {
                    resolve(JSON.parse(responseBody));
                }
                catch (err) {
                    reject(err);
                }
            });
        });
        req.on("error", (err) => {
            reject(err);
        });
        req.write(data);
        req.end();
    });
};
const httpTrigger = async function (context, request, customAuth) {
    var _a, _b, _c, _d, _e, _f;
    const providerName = ((_b = (_a = context.bindingData) === null || _a === void 0 ? void 0 : _a.provider) === null || _b === void 0 ? void 0 : _b.toLowerCase()) || "";
    if (providerName != "github" && providerName != "google") {
        context.res = (0, core_1.response)({
            context,
            status: 404,
            headers: { ["Content-Type"]: "text/plain" },
            body: `Provider '${providerName}' not found`,
        });
        return;
    }
    const { cookie } = request.headers;
    if (!cookie || !(0, core_1.validateAuthContextCookie)(cookie)) {
        context.res = (0, core_1.response)({
            context,
            status: 401,
            headers: { ["Content-Type"]: "text/plain" },
            body: "Invalid login request",
        });
        return;
    }
    const url = new URL(request.url, `${constants_1.SWA_CLI_APP_PROTOCOL}://${(_c = request === null || request === void 0 ? void 0 : request.headers) === null || _c === void 0 ? void 0 : _c.host}`);
    const codeValue = url.searchParams.get("code");
    const stateValue = url.searchParams.get("state");
    const authContext = (0, core_1.decodeAuthContextCookie)(cookie);
    if (!(authContext === null || authContext === void 0 ? void 0 : authContext.authNonce) || (0, auth_1.hashStateGuid)(authContext.authNonce) !== stateValue) {
        context.res = (0, core_1.response)({
            context,
            status: 401,
            headers: { ["Content-Type"]: "text/plain" },
            body: "Invalid login request",
        });
        return;
    }
    if ((0, auth_1.isNonceExpired)(authContext.authNonce)) {
        context.res = (0, core_1.response)({
            context,
            status: 401,
            headers: { ["Content-Type"]: "text/plain" },
            body: "Login timed out. Please try again.",
        });
        return;
    }
    const { clientIdSettingName, clientSecretSettingName } = ((_e = (_d = customAuth === null || customAuth === void 0 ? void 0 : customAuth.identityProviders) === null || _d === void 0 ? void 0 : _d[providerName]) === null || _e === void 0 ? void 0 : _e.registration) || {};
    if (!clientIdSettingName) {
        context.res = (0, core_1.response)({
            context,
            status: 404,
            headers: { ["Content-Type"]: "text/plain" },
            body: `ClientIdSettingName not found for '${providerName}' provider`,
        });
        return;
    }
    if (!clientSecretSettingName) {
        context.res = (0, core_1.response)({
            context,
            status: 404,
            headers: { ["Content-Type"]: "text/plain" },
            body: `ClientSecretSettingName not found for '${providerName}' provider`,
        });
        return;
    }
    const clientId = process.env[clientIdSettingName];
    if (!clientId) {
        context.res = (0, core_1.response)({
            context,
            status: 404,
            headers: { ["Content-Type"]: "text/plain" },
            body: `ClientId not found for '${providerName}' provider`,
        });
        return;
    }
    const clientSecret = process.env[clientSecretSettingName];
    if (!clientSecret) {
        context.res = (0, core_1.response)({
            context,
            status: 404,
            headers: { ["Content-Type"]: "text/plain" },
            body: `ClientSecret not found for '${providerName}' provider`,
        });
        return;
    }
    const clientPrincipal = providerName === "github"
        ? await getGitHubClientPrincipal(codeValue, clientId, clientSecret)
        : await getGoogleClientPrincipal(codeValue, clientId, clientSecret);
    if (clientPrincipal !== null && (customAuth === null || customAuth === void 0 ? void 0 : customAuth.rolesSource)) {
        try {
            const rolesResult = (await getRoles(clientPrincipal, customAuth.rolesSource));
            clientPrincipal.userRoles.push(...rolesResult.roles);
        }
        catch { }
    }
    const authCookieString = clientPrincipal && JSON.stringify(clientPrincipal);
    const authCookieEncrypted = authCookieString && (0, auth_1.encryptAndSign)(authCookieString);
    const authCookie = authCookieEncrypted ? btoa(authCookieEncrypted) : undefined;
    const cookiesManager = new core_1.CookiesManager(request.headers.cookie);
    cookiesManager.addCookieToDelete("StaticWebAppsAuthContextCookie");
    if (authCookie) {
        cookiesManager.addCookieToSet({
            name: "StaticWebAppsAuthCookie",
            value: authCookie,
            domain: config_1.DEFAULT_CONFIG.host,
            path: "/",
            secure: true,
            httpOnly: true,
            expires: new Date(Date.now() + 1000 * 60 * 60 * 8).toUTCString(),
        });
    }
    context.res = (0, core_1.response)({
        context,
        cookies: cookiesManager.getCookies(),
        status: 302,
        headers: {
            status: 302,
            Location: (_f = authContext.postLoginRedirectUri) !== null && _f !== void 0 ? _f : "/",
        },
        body: "",
    });
};
exports.default = httpTrigger;
//# sourceMappingURL=auth-login-provider-callback.js.map